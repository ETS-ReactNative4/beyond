/************
 Processor: ts
 ************/

import * as dependency_0 from '@beyond-js/kernel/core/ts';

// FILE: config/config.d.ts
declare namespace ns_config_config {
    import PagesConfig = ns_config_pages.PagesConfig;
    import LayoutsConfig = ns_config_layouts.LayoutsConfig;
    const config: {
        readonly "__#24094@#layouts": LayoutsConfig;
        readonly layouts: LayoutsConfig;
        readonly "__#24094@#pages": PagesConfig;
        readonly pages: PagesConfig;
    };
}

// FILE: config/layouts.d.ts
declare namespace ns_config_layouts {
    interface ILayoutConfig {
        name: string;
        layout?: string;
    }
    class LayoutConfig implements ILayoutConfig {
        #private;
        get is(): string;
        get name(): string;
        get id(): string;
        get layout(): string;
        constructor(config: ILayoutConfig);
    }
    class LayoutsConfig extends Map<string, LayoutConfig> {
        register(layouts: ILayoutConfig[]): void;
    }
}

// FILE: config/pages.d.ts
declare namespace ns_config_pages {
    interface IPageConfig {
        name: string;
        route?: string;
        layout?: string;
    }
    class PageConfig implements IPageConfig {
        #private;
        get is(): string;
        get name(): string;
        get route(): string;
        get layout(): string;
        constructor(page: IPageConfig);
    }
    class PagesConfig extends Map<string, PageConfig> {
        register(pages: IPageConfig[]): void;
    }
}

// FILE: history/history.d.ts
declare namespace ns_history_history {
    /**
     * Beyond keeps its own history list
     * @constructor
     */
    class BeyondHistory {
        #private;
        get initial(): number;
        get records(): string[];
        get length(): number;
        get position(): number;
        get current(): string;
        get previous(): string;
        get following(): string;
        replaceState(state: any, title: any, url: any): void;
        pushState(url: string, state: any): void;
        constructor();
    }
}

// FILE: history/position.d.ts
declare namespace ns_history_position {
    /**
     * The position of the navigation is stored this way:
     *      1. In the state of each page (the history.state object), it is stored the position
     *         in which the page is located. To achieve this, the __beyond_navigation_position property
     *         is added to the state object.
     *      2. In the sessionStorage is stored the current position (__beyond_navigation_position)
     */
    class HistoryPosition {
        #private;
        get valid(): boolean;
        /**
         * Returns the position from the history.state
         * @returns {number | undefined}
         */
        get value(): number | undefined;
        /**
         * Check if the position is already stored in the history.state.
         * If it is not, then an error message is shown.
         *
         * @returns {boolean}
         */
        get checkStateIsSet(): boolean;
        /**
         * Set the position in the history.state
         *
         * @param state {any} The state object before being stored in the history.state. In this method
         * the state object will be updated to store the position
         * @param {number} position
         */
        updateState(state: any, position?: number): void;
        /**
         * Stores in the sessionStorage the position getting its value from the history.state
         */
        updateSessionStorageFromState(): void;
        /**
         * Returns the position of the navigation flow from the sessionStorage
         * @returns {string}
         */
        getFromSessionStorage(): number | undefined;
        /**
         * Returns the position of the navigation flow from the history.state.
         * It is equivalent to obtaining this same value directly from the .state property,
         * with the difference that the .state property verifies that the value is stored
         * and displays an error if it is not
         * @returns {any}
         */
        getFromState: () => any;
    }
}

// FILE: history/records.d.ts
declare namespace ns_history_records {
    import HistoryPosition = ns_history_position.HistoryPosition;
    class HistoryRecords {
        #private;
        get data(): string[];
        get length(): number;
        get current(): string;
        get previous(): string;
        get following(): string;
        constructor(position: HistoryPosition);
        get: (index: number) => string;
        /**
         * Push a url to the records stored in the sessionStorage
         * @param {string} url
         */
        push(url: string): void;
        /**
         * Reset the list of records from the current position
         * This is required when:
         *      1. The list of browsed pages is greater than one (ex: page1 and page2)
         *      2. The user goes back in the history (ex: to position 1: page1)
         *      3. The user navigates another page (ex: page3)
         *
         * In step 3 is required this method, to clean the records from position 1, and after this
         * execution, the navigation flow can push page3
         */
        resetFromPosition(): void;
        updateCurrentUrl(url: any): void;
    }
}

// FILE: layouts/child.d.ts
declare namespace ns_layouts_child {
    import LayoutConfig = ns_config_layouts.LayoutConfig;
    import PageInstanceData = ns_pages_data.PageInstanceData;
    class Child {
        #private;
        get name(): string;
        get is(): string;
        get id(): string;
        get layout(): any;
        get children(): any;
        get active(): boolean;
        constructor(config: LayoutConfig | PageInstanceData);
        show(): void;
        hide(): void;
    }
}

// FILE: layouts/layout.d.ts
declare namespace ns_layouts_layout {
    import PageInstanceData = ns_pages_data.PageInstanceData;
    import Child = ns_layouts_child.Child;
    import Events = dependency_0.Events;
    class Layout extends Events {
        #private;
        get children(): Map<string, Child>;
        constructor(parent?: Layout);
        /**
         * Selects a page
         *
         * @param {PageInstanceData} page The page being selected (navigated)
         */
        select(page: PageInstanceData): void;
    }
}

// FILE: manager.d.ts
declare namespace ns_manager {
    import Layout = ns_layouts_layout.Layout;
    import Pages = ns_pages_pages.Pages;
    import URI = ns_uri_uri.URI;
    class Manager {
        #private;
        get main(): Layout;
        get pages(): Pages;
        set(uri: URI): void;
    }
}

// FILE: pages/data.d.ts
declare namespace ns_pages_data {
    import URI = ns_uri_uri.URI;
    import PageConfig = ns_config_pages.PageConfig;
    import LayoutConfig = ns_config_layouts.LayoutConfig;
    class PageInstanceData {
        #private;
        get is(): string;
        get id(): string;
        get name(): string;
        get route(): string;
        get parents(): LayoutConfig[];
        uri: URI;
        /**
         * Page instance data constructor
         *
         * @param {PageConfig} config
         * @param {LayoutConfig[]} parents The list of ascending layouts of the page
         */
        constructor(config: PageConfig, parents: LayoutConfig[]);
    }
}

// FILE: pages/pages.d.ts
declare namespace ns_pages_pages {
    import URI = ns_uri_uri.URI;
    import PageConfig = ns_config_pages.PageConfig;
    import LayoutConfig = ns_config_layouts.LayoutConfig;
    import PageInstanceData = ns_pages_data.PageInstanceData;
    type pathname = string;
    class Pages extends Map<pathname, PageInstanceData> {
        register(uri: URI, page: PageConfig, layouts: LayoutConfig[]): PageInstanceData;
    }
}

// FILE: routing.d.ts
declare namespace ns_routing {
    import URI = ns_uri_uri.URI;
    import Manager = ns_manager.Manager;
    import BeyondHistory = ns_history_history.BeyondHistory;
    enum RoutingMode {
        Hash = 0,
        Pathname = 1
    }
    class Routing {
        #private;
        get mode(): RoutingMode;
        get config(): {
            readonly "__#24094@#layouts": ns_config_layouts.LayoutsConfig;
            readonly layouts: ns_config_layouts.LayoutsConfig;
            readonly "__#24094@#pages": ns_config_pages.PagesConfig;
            readonly pages: ns_config_pages.PagesConfig;
        };
        get manager(): Manager;
        get uri(): URI;
        missing: (uri: URI) => string;
        redirect: (uri: URI) => string;
        get history(): BeyondHistory;
        get initialised(): boolean;
        setUp(routingMode: RoutingMode): void;
        pushState(url: string, state?: object): void;
        replaceState(state: object, title: string, url?: string): void;
        update: () => Promise<void>;
        back: () => void;
    }
    const routing: Routing;
}

// FILE: uri/querystring.d.ts
declare namespace ns_uri_querystring {
    class QueryString extends Map {
        constructor(search: string);
    }
}

// FILE: uri/route.d.ts
declare namespace ns_uri_route {
    import URI = ns_uri_uri.URI;
    class Route {
        #private;
        get route(): string;
        get bundle(): string;
        get vdir(): string;
        get initialised(): boolean;
        constructor(uri: URI);
        initialise(): Promise<void>;
    }
}

// FILE: uri/uri.d.ts
declare namespace ns_uri_uri {
    import Route = ns_uri_route.Route;
    import QueryString = ns_uri_querystring.QueryString;
    class URI {
        #private;
        get route(): Route;
        get url(): string;
        get pathname(): string;
        get protocol(): string;
        get hostname(): string;
        get origin(): string;
        get port(): string;
        get host(): string;
        get href(): string;
        get search(): string;
        get qs(): QueryString;
        constructor(href: string);
        initialise: () => Promise<void>;
    }
}

export import Layout = ns_layouts_layout.Layout;
export import routing = ns_routing.routing;

